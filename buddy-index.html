<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="styles.css" />
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/css/bootstrap.min.css"
      rel="stylesheet"
      integrity="sha384-sRIl4kxILFvY47J16cr9ZwB07vP4J8+LH7qKQnuqkuIAvNWLzeN8tE5YBujZqJLB"
      crossorigin="anonymous"
    />
    <title>SafeSpace: For Women</title>
  </head>
  <body>
    <!-- Adding a top bar here that will be reused -->
    <header class="top-bar">
      <div class="container-fluid d-flex justify-content-between align-items-center">
        <a href="index.html" class="text-white text-decoration-none fw-bold logo">SafeSpace</a>
        <div class="d-flex gap-2">
          <a href="about.html" class="top-bar-buttons">About us</a>
          <a href="profile.html" class="top-bar-buttons">Profile</a>
          <button onclick="logout()" class="top-bar-buttons" style="background: none; border: none; cursor: pointer;">Logout</button>
        </div>
      </div>
    </header>
    <div class="bg-image">
      <div class="container my-4 box-content">
        <h1>Requests:</h1>
        <p>
          Note to devs: Essentially on user-index.html, someone will locate a
          buddy nearby and select their desired buddy based on their stats and
          other characteristics. Those requests will appear here as a list where
          a buddy can accept or decline them.
        </p>
        <div class="box-body-content">
          <h1>REQUESTS</h1>
          <div id="noRequestsMsg" style="margin-top: 2rem; color: #666;">
            <p>No incoming requests at the moment. Waiting for users...</p>
          </div>
          <div id="requestSection" style="margin-top: 2rem; display: none; background: #f8f9fa; padding: 1.5rem; border-radius: 8px; border: 2px solid #007bff;">
            <h3 style="color: #007bff;">üîî Incoming Request</h3>
            <div id="requestInfo" style="margin-bottom: 1rem; font-size: 1.1rem;"></div>
            <button
              id="acceptBtn"
              class="btn btn-success"
              style="margin-right: 1rem"
            >
              ‚úì Accept
            </button>
            <button id="declineBtn" class="btn btn-danger">‚úó Decline</button>
          </div>
        </div>
        <div class="box-body-content">
          <h1>MAP</h1>
          <div
            id="map"
            style="height: 400px; width: 100%; margin-bottom: 16px"
          ></div>
        </div>
      </div>
    </div>
    <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDSy993VOiMVlKygiJf587UwDDAmH0wUNA&libraries=places,marker"></script>
    <script type="module">
      import { supabase } from './auth-pages/supabaseClient.js';
      
      let currentBuddyId = null;
      let currentRequest = null;
      let map, buddyMarker, clientMarker, destinationMarker;

      async function initMap(lat, lon) {
        const { Map } = await google.maps.importLibrary("maps");
        const { AdvancedMarkerElement, PinElement } = await google.maps.importLibrary("marker");
        
        map = new Map(document.getElementById("map"), {
          center: { lat, lng: lon },
          zoom: 15,
          mapId: "BUDDY_MAP"
        });
        
        const buddyPin = new PinElement({
          background: "#007bff",
          borderColor: "white",
          glyphColor: "white",
          glyph: "B"
        });
        
        buddyMarker = new AdvancedMarkerElement({
          position: { lat, lng: lon },
          map,
          title: "Your Location",
          content: buddyPin.element
        });
      }

      // Get buddy's current location
      async function fetchBuddyLocation() {
        try {
          if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(function (pos) {
              initMap(pos.coords.latitude, pos.coords.longitude);
            });
          }
        } catch (err) {
          initMap(40.7128, -74.006);
        }
      }

      // Display incoming request
      function showRequest(request) {
        currentRequest = request;
        const requestSection = document.getElementById("requestSection");
        const noRequestsMsg = document.getElementById("noRequestsMsg");
        const infoDiv = document.getElementById("requestInfo");
        
        // Calculate distance
        const distance = calculateDistance(
          buddyMarker.getPosition().lat(),
          buddyMarker.getPosition().lng(),
          request.user_lat,
          request.user_lon
        );
        
        infoDiv.innerHTML = `
          <p><b>üìç User Location:</b> ${request.user_lat.toFixed(4)}, ${request.user_lon.toFixed(4)}</p>
          <p><b>üéØ Destination:</b> ${request.destination || 'Not specified'}</p>
          <p><b>üìè Distance:</b> ${distance.toFixed(2)} km</p>
          <p><b>‚è∞ Request Time:</b> ${new Date(request.created_at).toLocaleTimeString()}</p>
        `;
        
        // Show request section, hide no requests message
        requestSection.style.display = 'block';
        noRequestsMsg.style.display = 'none';
        
        // Show client marker
        if (clientMarker) clientMarker.map = null;
        
        (async () => {
          const { AdvancedMarkerElement, PinElement } = await google.maps.importLibrary("marker");
          
          const userPin = new PinElement({
            background: "#d50000",
            borderColor: "white",
            glyphColor: "white",
            glyph: "U"
          });
          
          clientMarker = new AdvancedMarkerElement({
            position: { lat: request.user_lat, lng: request.user_lon },
            map,
            title: "User Location",
            content: userPin.element
          });
        })();
        
        // Show destination marker if available
        if (request.destination_lat && request.destination_lon) {
          if (destinationMarker) destinationMarker.map = null;
          
          (async () => {
            const { AdvancedMarkerElement, PinElement } = await google.maps.importLibrary("marker");
            
            const destPin = new PinElement({
              background: "#00c853",
              borderColor: "white",
              glyphColor: "white",
              glyph: "D"
            });
            
            destinationMarker = new AdvancedMarkerElement({
              position: { lat: request.destination_lat, lng: request.destination_lon },
              map,
              title: "Destination",
              content: destPin.element
            });
          })();
        }
        
        // Center map to show all markers
        setTimeout(() => {
          const bounds = new google.maps.LatLngBounds();
          bounds.extend(buddyMarker.position);
          if (clientMarker) bounds.extend(clientMarker.position);
          if (destinationMarker) bounds.extend(destinationMarker.position);
          map.fitBounds(bounds);
        }, 100);
      }
      
      // Calculate distance using Haversine formula
      function calculateDistance(lat1, lon1, lat2, lon2) {
        const R = 6371; // Earth's radius in km
        const dLat = (lat2 - lat1) * Math.PI / 180;
        const dLon = (lon2 - lon1) * Math.PI / 180;
        const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                  Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                  Math.sin(dLon/2) * Math.sin(dLon/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        return R * c;
      }

      // Setup real-time listener for incoming requests
      async function setupRealtimeListener() {
        const { data: { user } } = await supabase.auth.getUser();
        
        if (!user) {
          console.error('No authenticated buddy found');
          return;
        }
        
        currentBuddyId = user.id;
        console.log('[BUDDY] Setting up real-time listener for buddy:', currentBuddyId);
        
        // Listen for new requests (INSERT)
        const channel = supabase
          .channel('buddy-incoming-requests')
          .on(
            'postgres_changes',
            {
              event: 'INSERT',
              schema: 'public',
              table: 'buddy_requests',
              filter: `buddy_id=eq.${currentBuddyId}`
            },
            (payload) => {
              console.log('[BUDDY] New request received:', payload.new);
              // Only show if no current request or if current request is not pending
              if (!currentRequest || currentRequest.status !== 'pending') {
                console.log('[BUDDY] Displaying request:', payload.new.id);
                showRequest(payload.new);
              } else {
                console.log('[BUDDY] Request queued (current request active):', payload.new.id);
              }
            }
          )
          .on(
            'postgres_changes',
            {
              event: 'UPDATE',
              schema: 'public',
              table: 'buddy_requests',
              filter: `buddy_id=eq.${currentBuddyId}`
            },
            (payload) => {
              console.log('Request updated:', payload);
              // If the current request was accepted/declined by another buddy, hide it
              if (currentRequest && currentRequest.id === payload.new.id) {
                if (payload.new.status === 'accepted' || payload.new.status === 'declined') {
                  hideCurrentRequest();
                  // Check for next pending request
                  checkForNextRequest();
                }
              }
            }
          )
          .subscribe();
        
        // Check for existing pending requests
        console.log('[BUDDY] Checking for existing pending requests...');
        const { data: existingRequests } = await supabase
          .from('buddy_requests')
          .select('*')
          .eq('buddy_id', currentBuddyId)
          .eq('status', 'pending')
          .order('created_at', { ascending: false })
          .limit(1);
        
        console.log('[BUDDY] Existing pending requests:', existingRequests);
        if (existingRequests && existingRequests.length > 0) {
          console.log('[BUDDY] Showing existing request:', existingRequests[0].id);
          showRequest(existingRequests[0]);
        } else {
          console.log('[BUDDY] No existing requests found. Waiting for new requests...');
        }
      }
      
      // Hide current request
      function hideCurrentRequest() {
        document.getElementById('requestSection').style.display = 'none';
        document.getElementById('noRequestsMsg').innerHTML = '<p>Request no longer available. Waiting for new requests...</p>';
        document.getElementById('noRequestsMsg').style.display = 'block';
        
        // Clear markers
        if (clientMarker) clientMarker.map = null;
        if (destinationMarker) destinationMarker.map = null;
        
        currentRequest = null;
      }
      
      // Check for next pending request
      async function checkForNextRequest() {
        const { data: nextRequests } = await supabase
          .from('buddy_requests')
          .select('*')
          .eq('buddy_id', currentBuddyId)
          .eq('status', 'pending')
          .order('created_at', { ascending: false })
          .limit(1);
        
        if (nextRequests && nextRequests.length > 0) {
          showRequest(nextRequests[0]);
        }
      }

      // Accept request
      async function acceptRequest() {
        if (!currentRequest) return;
        
        console.log('[BUDDY] Accepting request:', currentRequest.id);
        
        try {
          const { error } = await supabase
            .from('buddy_requests')
            .update({ status: 'accepted', updated_at: new Date().toISOString() })
            .eq('id', currentRequest.id);
          
          if (error) {
            console.error('[BUDDY] Error accepting request:', error);
            alert('Failed to accept request. Please try again.');
            return;
          }
          
          console.log('[BUDDY] Request accepted successfully:', currentRequest.id);
          
          // Hide request section
          document.getElementById('requestSection').style.display = 'none';
          document.getElementById('noRequestsMsg').innerHTML = '<p style="color: green;">‚úì Request accepted! Connection established.</p>';
          document.getElementById('noRequestsMsg').style.display = 'block';
          
          currentRequest = null;
        } catch (err) {
          console.error('[BUDDY] Failed to accept request:', err);
          alert('Failed to accept request. Please try again.');
        }
      }

      // Decline request
      async function declineRequest() {
        if (!currentRequest) return;
        
        console.log('[BUDDY] Declining request:', currentRequest.id);
        
        try {
          const { error } = await supabase
            .from('buddy_requests')
            .update({ status: 'declined', updated_at: new Date().toISOString() })
            .eq('id', currentRequest.id);
          
          if (error) {
            console.error('[BUDDY] Error declining request:', error);
            alert('Failed to decline request. Please try again.');
            return;
          }
          
          console.log('[BUDDY] Request declined successfully:', currentRequest.id);
          
          // Hide request section
          document.getElementById('requestSection').style.display = 'none';
          document.getElementById('noRequestsMsg').innerHTML = '<p>Request declined. Waiting for new requests...</p>';
          document.getElementById('noRequestsMsg').style.display = 'block';
          
          // Clear markers
          if (clientMarker) clientMarker.map = null;
          if (destinationMarker) destinationMarker.map = null;
          
          currentRequest = null;
          
          // Check for next pending request
          checkForNextRequest();
        } catch (err) {
          console.error('[BUDDY] Failed to decline request:', err);
          alert('Failed to decline request. Please try again.');
        }
      }

      // Setup event listeners
      document.addEventListener("DOMContentLoaded", function () {
        document.getElementById("acceptBtn").addEventListener("click", acceptRequest);
        document.getElementById("declineBtn").addEventListener("click", declineRequest);
      });

      // Initialize
      fetchBuddyLocation();
      setupRealtimeListener();
    </script>
    <script type="module">
      import { supabase } from './auth-pages/supabaseClient.js';
      
      async function logout() {
        try {
          const { error } = await supabase.auth.signOut();
          if (error) {
            console.error('Logout error:', error);
          }
          localStorage.removeItem('userType');
          localStorage.removeItem('user_id');
          window.location.href = '/index.html';
        } catch (error) {
          console.error('Logout failed:', error);
        }
      }
      
      // Make logout available globally
      window.logout = logout;
      
      // Start tracking buddy location when page loads
      async function startBuddyLocationTracking() {
        const { data: { user } } = await supabase.auth.getUser();
        
        if (!user) {
          console.error('No authenticated user found');
          return;
        }
        
        const buddy_id = user.id;
        localStorage.setItem('user_id', buddy_id);
        
        // Get buddy name from database
        const { data: buddyData } = await supabase
          .from('buddies')
          .select('name')
          .eq('id', buddy_id)
          .single();
        
        const buddyName = buddyData?.name || 'Buddy';
        
        if (navigator.geolocation) {
          // Get initial location and update database
          navigator.geolocation.getCurrentPosition(
            async (position) => {
              const lat = position.coords.latitude;
              const lng = position.coords.longitude;
              
              await fetch('/volunteer-location', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ id: buddy_id, name: buddyName, lat, lng, available: true })
              });
              
              console.log('Initial buddy location updated');
            },
            (error) => {
              console.error('Error getting buddy location:', error);
            }
          );
          
          // Continuously track location
          navigator.geolocation.watchPosition(
            async (position) => {
              const lat = position.coords.latitude;
              const lng = position.coords.longitude;
              
              await fetch('/volunteer-location', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ id: buddy_id, name: buddyName, lat, lng, available: true })
              });
            },
            (error) => {
              console.error('Error tracking buddy location:', error);
            },
            { enableHighAccuracy: true }
          );
        }
      }
      
      // Start tracking when page loads
      startBuddyLocationTracking();
    </script>
  </body>
</html>
